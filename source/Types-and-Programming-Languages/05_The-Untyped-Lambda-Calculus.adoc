= 5. The Untyped Lambda-Calclus
:math: latexmath

型なしラムダ計算。link:03_Untyped-Arithmetic-Expressions.html[3章]で簡単な言語を設計したが、これをさらにラムダ計算という枠組みに落とし込むことができる。実のところ複雑なプログラミング言語も、その本質をついたラムダ計算という小さな言語で表し、理解することができる。

ラムダ計算の重要な点は、

* ラムダ計算が計算を行うものであるのと同時に、
* ラムダ計算における命題が厳密に証明可能な数学的対象である、

ということ。

== 5.1 Basics

=== Operational Semantics

math:[[x \mapsto t_2\]t_{12}] とかいうよくわからん記法が出てきたがこれもひとつの関数。そういって悪ければ厳密に定義された手続きである。

== 5.2 Programming in the Lambda-Calculus

=== Multiple Arguments

定期的に話題になる**カリー化**について。そもそも要求としては、計算を表すものであるラムダ式では（ラムダ抽象の定義を見ればわかるように）1引数の関数しか直接には表わせなそうであるところ、複数引数の関数をラムダ式で表したい。ラムダ計算において（1引数の）関数は項の中の自由変数の出現を書き換えることのできるラムダ抽象で表わされたから、複数引数の関数というのは複数の自由変数出現を書き換えることのできるラムダ抽象だ。複数の引数を一度に与える代わりに、複数回適用を行うということにする。この複数引数関数から高階関数への変換をカリー化と呼ぶ。

=== Church Booleans

ラムダ計算にブーリアンを持ち込む。このシンプルな言語がこれだけの表現力を持っていることに注目。ここで +tru+, +fls+ を定義しただけでは意味がなくて、+test+ （+if+ 相当）を定義してはじめてこれらの値がブーリアンとして意味を持つことにも注意。+tru+ や +test+ といった項それ自身がその意味を知っている、内包しているわけではなく、ある真っ当な意味論のもとでこれらの組み合わせが期待した挙動を示す（人間の脳内モデルに対応した意味が導出される）のである。+pair+ と +fst+, +snd+ の場合も同様に、値（の組み立て）とそれに対する演算の両方があってはじめて意味が現われる。

=== Ex. 5.2.4

+plus+, +times+ と定義してきたところで、累乗を定義する。TBD

=== Ex. 5.2.8

リスト +[x,y,z]+ を +λc. λn. c x (c y (c z n))+ という式で表すことにするとき、+nil+, +isnil+, +head+, +tail+ はそれぞれどうなるか。TBD

=== Enriching the Calculus

真偽値、数値といった概念をラムダ計算により表せることがわかったとはいえ、簡便さのため以前に定義した真偽値、数値とそれに対する演算をラムダ計算に組み込んだ言語を考えることもある（厳密な定義は記されていないけれど、λ抽象、λ適用と並んで **NB** の項があるような文法だろう）。純粋なラムダ計算**λ**と区別するため**λNB**と表記する。

+realnat+ の解説。

[math]
++++
realnat = \lambda m. m \; \mathrm{succ} \; 0
++++

と定義することはできない。文法的に +succ+ は何かに適用する形でしか存在しえないからだ。
