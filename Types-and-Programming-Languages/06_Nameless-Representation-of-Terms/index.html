<!DOCTYPE html><html><head><title>6. Nameless Representation of Terms - Types and Programming Languages</title><meta content="width=device-width" name="viewport" /><link href="../../stylesheets/all.css" rel="stylesheet" type="text/css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({  tex2jax: {    inlineMath: [["\\(", "\\)"]],    displayMath: [["\\[", "\\]"]],    ignoreClass: "nomath|nolatexmath"  },  asciimath2jax: {    delimiters: [["\\$", "\\$"]],    ignoreClass: "nomath|noasciimath"  }});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML" type="text/javascript"></script><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700|Roboto+Slab:400,700" rel="stylesheet" type="text/css" /><script type="text/javascript">document.addEventListener('DOMContentLoaded', MathJax.Hub.TypeSet)</script></head><body><div id="container"><article id="content"><h1>6. Nameless Representation of Terms</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="../05_The-Untyped-Lambda-Calculus/">5章 The Untyped Lambda-Calculus</a>で束縛変数の名前は自由に書き換えてよいという話をしたけれど、さてそれをどうすれば実現できるか？　という話。人間がこれに取り組むのであれば直感によって新たな名前を考案すればよいが、もちろんここの手順を厳密に定義したい。</p>
</div>
<div class="paragraph">
<p>いろいろ方法は挙げられているけれど、この章では、項から変数の名前を取り去った形に項を正規化することで、そもそも名前の書き換えを不要にする、という方法を採る。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_1_terms_and_contexts">6.1 Terms and Contexts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>De Brujin の方法では、束縛変数がそれから外側に数えて何番目のλによって導入されたか、という番号で表す（\(λ.λ.1 (0 1)\) など）。そうして表され名前なしとなった項を De Brujin Term、番号を De Brujin Index と呼ぶ。</p>
</div>
<div class="paragraph">
<p>自由変数を扱えるようにするために、<strong>naming context</strong> \(\Gamma\) というものを導入する。これは変数名から de Brujin index への対応である。</p>
</div>
<div class="sect2">
<h3 id="_ex_6_1_5">Ex. 6.1.5</h3>
<div class="paragraph">
<p>項を無名化する \(removenames\) と名前なし項に名前をつける \(restorenames\) を定義する。例によって工夫がいるのはラムダ抽象のパート。restorenames を定義するには、ラムダ抽象で束縛される変数名を作り出す操作が必要になる。ここではあり得る変数名の集合が順序付けられていて、\(\Gamma\) 中の変数名が互いに異なる［この条件が何に効くのかよくわからない］と仮定して、\(\Gamma\) の定義域に含まれていない変数名を選び出す、という操作が可能だということにしてよい。</p>
</div>
<div class="mathblock">
<div class="title">removenames</div>
<div class="content">
\[\begin{eqnarray}
removenames_\Gamma (x) \; &amp;=&amp; \Gamma(x) \\
removenames_\Gamma (t_1 \; t_2) \; &amp;=&amp; removenames_\Gamma(t_1) \; removenames_\Gamma(t_2) \\
removenames_\Gamma (λx.t) \; &amp;=&amp; λ.removenames_{\Gamma'}(t) \\ &amp;&amp; \; \mathrm{where} \; \Gamma' = \{ x \mapsto 0, \Gamma(0) \mapsto 1, \dots \}
\end{eqnarray}\]
</div>
</div>
<div class="mathblock">
<div class="title">restorenames</div>
<div class="content">
\[\begin{eqnarray}
restorenames_\Gamma (n) \; &amp;=&amp; \Gamma^{-1} (n) \\
restorenames_\Gamma (n \; m) \; &amp;=&amp; restorenames_\Gamma(n) \; restorenames_\Gamma(m) \\
restorenames_\Gamma (λ.t) \; &amp;=&amp; λx.restorenames_{\Gamma'}(t) \\
                             &amp; &amp; \mathrm{where} \; x \not \in \mathrm{dom}(\Gamma) \\ &amp;&amp; \Gamma' = \{ x \mapsto 0, \Gamma(0) \mapsto 1, \dots \}
\end{eqnarray}\]
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_2_shifting_and_substitution">6.2 Shifting and Substitution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>次は書き換え \([k \mapsto s] t\) を名前なし項において定義する。書き換えがラムダ抽象の中に及ぶときには、書き換え先の項を包むλの数が1だけ増えるので、自由変数のインデックスにも1を加えてやる（1だけシフトする）必要がある。
例えば、\([1 \mapsto s](λ. 2)\) （\([x \mapsto s](λy.x)\)）では、書き換え後の \(s\) はそれを包むλの数が1だけ多い。</p>
</div>
<div class="paragraph">
<p>ただし束縛変数のことを考えると、無条件にインデックスをシフトさせることはできない。
例えば、\(s = 2 \; (λ.0)\) （\(s = z \; (λw.w)\)） のうち <code>2</code> をシフトするのはよいが <code>0</code> をシフトするとおかしい。</p>
</div>
<div class="paragraph">
<p>結局シフト関数 \(↑^d_c(-)\) は「インデックスにいくつだけ加えるか」と「いくつ未満のインデックスはシフトしないか」の2つのパラメータを持つことになる。</p>
</div>
<div class="sect2">
<h3 id="_ex_6_2_8">Ex. 6.2.8</h3>
<div class="paragraph">
<p>名前なし項における書き換えの定義は、名前ありの項における書き換えの定義と一致していなければいけない。(1) そのために示されるべき定理はなにか？ (2) 証明せよ。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ある書き換えを行ってから無名化した時と、無名化してから書き換えをおこなった時とで同じ結果が得られること。</p>
</li>
<li>
<p>省略。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_3_evaluation">6.3 Evaluation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>名前なし項の評価をおこなえるようにするにはベータ簡約のルールを新たに決めればよい。今回は簡約後にλの数が減るので、インデックスを減らす必要がある。先ほどのシフト関数が \(↑^{-1}\) という形でそのまま利用できる。</p>
</div>
<div class="paragraph">
<p>\((λ.1 \; 0 \; 2) \; (λ.0)\) は \(0 \; (λ.0) \; 1\) に簡約される。\(1\; (λ.0) \; 2\) でないことに注意。</p>
</div>
</div>
</div><nav class="pager"><a rel="prev" href="../05_The-Untyped-Lambda-Calculus/">≪ 5. The Untyped Lambda-Calculus</a></nav><div id="comments-container"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'motemen-studynote'; // required: replace example with your forum shortname
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></article><aside><div class="textbook"><h1 class="title">Types and Programming Languages</h1><ul class="links"><li><a href="http://www.amazon.co.jp/gp/product/B00AJXZ5JE/ref=as_li_ss_il?ie=UTF8camp=247&amp;creative=7399&amp;creativeASIN=B00AJXZ5JE&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/51mYUDN2%2BIL.jpg" ><br>Types and Programming Languages</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=B00AJXZ5JE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li><li><a href="http://www.amazon.co.jp/gp/product/4274069117/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4274069117&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/41gusdgRAkL.jpg" ><br>型システム入門</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=4274069117" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li></ul></div><ul class="sitemap"><li><strong><a href="../">Types and Programming Languages</a></strong><ul><li><a href="../01_Introduction/">1. Introduction</a></li><li><a href="../03_Untyped-Arithmetic-Expressions/">3. Untyped Arithmetic Expressions</a></li><li><a href="../05_The-Untyped-Lambda-Calculus/">5. The Untyped Lambda-Calculus</a></li><li><a href="./">6. Nameless Representation of Terms</a></li></ul></li></ul></aside></div><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-34276254-4', 'auto');
ga('send', 'pageview');</script></body></html>