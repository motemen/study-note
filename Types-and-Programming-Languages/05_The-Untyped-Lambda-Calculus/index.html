<!DOCTYPE html><html><head><title>5. The Untyped Lambda-Calculus - Types and Programming Languages</title><meta content="width=device-width" name="viewport" /><link href="../../stylesheets/all.css" rel="stylesheet" type="text/css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({  tex2jax: {    inlineMath: [["\\(", "\\)"]],    displayMath: [["\\[", "\\]"]],    ignoreClass: "nomath|nolatexmath"  },  asciimath2jax: {    delimiters: [["\\$", "\\$"]],    ignoreClass: "nomath|noasciimath"  }});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML" type="text/javascript"></script><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700|Roboto+Slab:400,700" rel="stylesheet" type="text/css" /><script type="text/javascript">document.addEventListener('DOMContentLoaded', MathJax.Hub.TypeSet)</script></head><body><div id="container"><article id="content"><h1>5. The Untyped Lambda-Calculus</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>型なしラムダ計算。<a href="../03_Untyped-Arithmetic-Expressions/">3章</a>で簡単な言語を設計したが、これをさらにラムダ計算という枠組みに落とし込むことができる。実のところ複雑なプログラミング言語も、その本質をついたラムダ計算という小さな言語で表し、理解することができる。</p>
</div>
<div class="paragraph">
<p>ラムダ計算の重要な点は、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ラムダ計算が計算を行うものであるのと同時に、</p>
</li>
<li>
<p>ラムダ計算における命題が厳密に証明可能な数学的対象である、</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ということ。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_1_basics">5.1 Basics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_operational_semantics">Operational Semantics</h3>
<div class="paragraph">
<p>\([x \mapsto t_2]t_{12}\) とかいうよくわからん記法が出てきたがこれもひとつの関数。そういって悪ければ厳密に定義された手続きである。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_programming_in_the_lambda_calculus">5.2 Programming in the Lambda-Calculus</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_multiple_arguments">Multiple Arguments</h3>
<div class="paragraph">
<p>定期的に話題になる<strong>カリー化</strong>について。そもそも要求としては、計算を表すものであるラムダ式では（ラムダ抽象の定義を見ればわかるように）1引数の関数しか直接には表わせなそうであるところ、複数引数の関数をラムダ式で表したい。ラムダ計算において（1引数の）関数は項の中の自由変数の出現を書き換えることのできるラムダ抽象で表わされたから、複数引数の関数というのは複数の自由変数出現を書き換えることのできるラムダ抽象だ。複数の引数を一度に与える代わりに、複数回適用を行うということにする。この複数引数関数から高階関数への変換をカリー化と呼ぶ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_church_booleans">Church Booleans</h3>
<div class="paragraph">
<p>ラムダ計算にブーリアンを持ち込む。このシンプルな言語がこれだけの表現力を持っていることに注目。ここで <code>tru</code>, <code>fls</code> を定義しただけでは意味がなくて、<code>test</code> （<code>if</code> 相当）を定義してはじめてこれらの値がブーリアンとして意味を持つことにも注意。<code>tru</code> や <code>test</code> といった項それ自身がその意味を知っている、内包しているわけではなく、ある真っ当な意味論のもとでこれらの組み合わせが期待した挙動を示す（人間の脳内モデルに対応した意味が導出される）のである。<code>pair</code> と <code>fst</code>, <code>snd</code> の場合も同様に、値（の組み立て）とそれに対する演算の両方があってはじめて意味が現われる。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ex_5_2_4">Ex. 5.2.4</h3>
<div class="paragraph">
<p><code>plus</code>, <code>times</code> と定義してきたところで、冪乗を定義する。</p>
</div>
<div class="mathblock">
<div class="content">
\[pow = λm.λn.n \; (\mathrm{times} \; m) \; c_1\]
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ex_5_2_8">Ex. 5.2.8</h3>
<div class="paragraph">
<p>リスト <code>[x,y,z]</code> を <code>λc. λn. c x (c y (c z n))</code> という式で表すことにするとき、<code>nil</code>, <code>isnil</code>, <code>head</code>, <code>tail</code> はそれぞれどうなるか。</p>
</div>
<div class="mathblock">
<div class="content">
\[nil = λ c.λ n.n \\
cons = λ x.λ xs.λ c.λ n.c \; x \; (xs \; c \; n) \\
head = λ xs.xs \; \mathrm{tru} \; \mathrm{tru}\]
</div>
</div>
<div class="paragraph">
<p><a href="http://motemen.github.io/lambda-calculator/untyped.html?s=call-by-value#(%5Cxs.xs%20$tru%20$tru)%20(%5Cc.%5Cn.c%20(%5CA.A)%20(c%20(%5CB.B)%20n))">head の確認</a>（\(head \; [A,B] \longrightarrow^* A\)）</p>
</div>
<div class="paragraph">
<p><code>tail</code> はちょっと工夫がいる。テキストの <code>pred</code> をそのまま真似すると:</p>
</div>
<div class="mathblock">
<div class="content">
\[nn = \mathrm{pair} \; \mathrm{nil} \; \mathrm{nil} \\
cc = λ x.λ xs.\mathrm{pair} \; (\mathrm{snd} \; xs) \; (\mathrm{cons} \; x \; (\mathrm{snd} \; xs)) \\
tail = λ xs.\mathrm{fst} \; (xs \; cc \; nn)\]
</div>
</div>
<div class="paragraph">
<p><a href="http://motemen.github.io/lambda-calculator/untyped.html?s=call-by-value#(%5Cxs.$fst%20(xs%20(%5Cx.%5Cxs.$pair%20($snd%20xs)%20%5Cx.%5Cxs.%5Cc.%5Cn.c%20x%20(xs%20c%20n%20x%20($snd%20xs)))%20($pair%20(%5Cc.%5Cn.n)%20(%5Cc.%5Cn.n))))%20(%5Cc.%5Cn.c%20(%5CA.A)%20(c%20(%5CB.B)%20n))">tail の確認</a>（\(tail \; [A,B] \longrightarrow^* [B]\)）</p>
</div>
</div>
<div class="sect2">
<h3 id="_enriching_the_calculus">Enriching the Calculus</h3>
<div class="paragraph">
<p>真偽値、数値といった概念をラムダ計算により表せることがわかったとはいえ、簡便さのため以前に定義した真偽値、数値とそれに対する演算をラムダ計算に組み込んだ言語を考えることもある（厳密な定義は記されていないけれど、λ抽象、λ適用と並んで <strong>NB</strong> の項があるような文法だろう）。純粋なラムダ計算<strong>λ</strong>と区別するため<strong>λNB</strong>と表記する。</p>
</div>
<div class="paragraph">
<p><code>realnat</code> の解説。</p>
</div>
<div class="mathblock">
<div class="content">
\[realnat = λ m. m \; \mathrm{succ} \; 0\]
</div>
</div>
<div class="paragraph">
<p>と定義することはできない。文法的に <code>succ</code> は何かに適用する形でしか存在しえないからだ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_recursion">Recursion</h3>
<div class="paragraph">
<p>待ってました！　みんな大好きYコンビネータ。</p>
</div>
<div class="paragraph">
<p>今取り扱っているラムダ計算では式に名前をつけるようなことができないので、当然、項の中からその項自身を参照するという、普通に想像するようなやり方で再帰を行うことはできない。ここで登場する <code>fix</code> と名付けられた項は、引数を与えて簡約するとうまい具合にその引数を複製する性質があり、これを利用して再帰を実現することができる。この式の形は天下り的に登場するので、あまり深く考える必要はないかも。ただ自分で簡約してみるとちょっとわかったような気持ちになれる。</p>
</div>
<div class="paragraph">
<p><code>fix = λf.(λx.(f (λy. (x x) y))) (λx.(f (λy. (x x) y)))</code> は有名なYコンビネータ <code>Y = λf.(λx.(f (x x))) (λx.(f (x x)))</code> とは少し違った形をしているが、これは call-by-value では <code>Y</code> が発散してしまうのを修正したバージョンだということらしい。</p>
</div>
</div>
<div class="sect2">
<h3 id="_representation">Representation</h3>
<div class="paragraph">
<p>さてここで、チャーチ数を用いて普通の数を表すことができるとはどういうことだろうか？　という話。そもそもここで考えてる数ってなんだろうか？　ということから考える。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>0 は数である。</p>
</li>
<li>
<p><code>iszero</code> という、数から真偽値への関数がある。</p>
</li>
<li>
<p><code>succ</code>, <code>pred</code> という、数から数への関数がある。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>iszero</code>, <code>succ</code>, <code>pred</code> の意味論については Figure 3-2 にある通り。このそれぞれをチャーチ数の定義が満たしているので、数が実現できているという話。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_3_formalities">5.3 Formalities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>このラムダ計算の文法および操作的意味論の定義を考える。</p>
</div>
<div class="sect2">
<h3 id="_syntax">Syntax</h3>
<div class="paragraph">
<p><strong>Def 5.3.2</strong> で項 \(t\) 中の<em>自由変数</em>（<em>free variables</em>）\(FV(t)\)が定義される。</p>
</div>
</div>
<div class="sect2">
<h3 id="_substitution">Substitution</h3>
<div class="paragraph">
<p>項の書き換えは実際に定義しようとすると少し工夫がいる。テキストでは誤りのある定義を踏まえながら、正しい定義に誘導している。</p>
</div>
<div class="paragraph">
<p>ここのポイントは以下の通り。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\([x \mapsto y](λx.x)\) の結果が \(λx.y\) であってはいけない（束縛変数を書き換えてはいけない）</p>
</li>
<li>
<p>\([x \mapsto z](λz.x)\) の結果が \(λz.z\) であってはいけない（自由変数を書き換えた結果束縛変数になってしまってはいけない）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>人間が意味を考えると間違えようのないところだけれど、きちんと定式化するならこういう落とし穴を避けられる必要がある。結局このテキストではどうしているかというと、上記2例のような事態にならないときについてだけ書き換えの操作を定義し、それ以外の場合については登場する束縛変数の名前を新しいものに書き換えることとしている。チャーチの言葉によるとこれを<em>α変換</em>（<em>alpha-conversion</em>）と呼ぶ。束縛変数の名前だけが異なるラムダ項は同じものとして扱う（<strong>Convention 5.3.4</strong>）ことによって、この書き換えが、すべてのラムダ項に対して定義されることになる。</p>
</div>
<div class="paragraph">
<p>書き換える先の名前の候補は無限にあるから上手くいくのは確かだが、名前の決め方が定義されていないのっていいのかな……とモヤモヤするが、次の章では別の方法が紹介され、そちらは完全にアルゴリズムが決まっているので心配しなくともよい。</p>
</div>
</div>
<div class="sect2">
<h3 id="_operational_semantics_2">Operational Semantics</h3>
<div class="paragraph">
<p>見慣れた意味論だけれど、ここでは数値や真偽値ではなく、ラムダ抽象が最終的な評価結果、値となる。</p>
</div>
</div>
</div>
</div><nav class="pager"><a rel="prev" href="../03_Untyped-Arithmetic-Expressions/">≪ 3. Untyped Arithmetic Expressions</a><a rel="next" href="../06_Nameless-Representation-of-Terms/">6. Nameless Representation of Terms ≫</a></nav><div id="comments-container"><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'motemen-studynote'; // required: replace example with your forum shortname
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></article><aside><div class="textbook"><h1 class="title">Types and Programming Languages</h1><ul class="links"><li><a href="http://www.amazon.co.jp/gp/product/B00AJXZ5JE/ref=as_li_ss_il?ie=UTF8camp=247&amp;creative=7399&amp;creativeASIN=B00AJXZ5JE&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/51mYUDN2%2BIL.jpg" ><br>Types and Programming Languages</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=B00AJXZ5JE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li><li><a href="http://www.amazon.co.jp/gp/product/4274069117/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4274069117&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/41gusdgRAkL.jpg" ><br>型システム入門</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=4274069117" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li></ul></div><ul class="sitemap"><li><strong><a href="../">Types and Programming Languages</a></strong><ul><li><a href="../01_Introduction/">1. Introduction</a></li><li><a href="../03_Untyped-Arithmetic-Expressions/">3. Untyped Arithmetic Expressions</a></li><li><a href="./">5. The Untyped Lambda-Calculus</a></li><li><a href="../06_Nameless-Representation-of-Terms/">6. Nameless Representation of Terms</a></li></ul></li></ul></aside></div><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-34276254-4', 'auto');
ga('send', 'pageview');</script></body></html>