<!DOCTYPE html><html><head><title>3. Untyped Arithmetic Expressions - Types and Programming Languages</title><meta content="width=device-width" name="viewport" /><link href="../../stylesheets/all.css" rel="stylesheet" type="text/css" /><script type="text/x-mathjax-config">MathJax.Hub.Config({  tex2jax: {    inlineMath: [["\\(", "\\)"]],    displayMath: [["\\[", "\\]"]],    ignoreClass: "nomath|nolatexmath"  },  asciimath2jax: {    delimiters: [["\\$", "\\$"]],    ignoreClass: "nomath|noasciimath"  }});</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML" type="text/javascript"></script><link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700|Roboto+Slab:400,700" rel="stylesheet" type="text/css" /><script type="text/javascript">document.addEventListener('DOMContentLoaded', MathJax.Hub.TypeSet)</script></head><body><div id="container"><article id="content"><h1>3. Untyped Arithmetic Expressions</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>まずは話題の対象として、プログラミング言語の基本的な側面を持つシンプルな言語を考える。これに厳密な定義をあたえることで、数学的に扱いやすい道具とし、今後もこれを発展させながら利用していくことになる。今回は真偽値と数値のみを扱えるような言語。</p>
</div>
<div class="paragraph">
<p>言語は、文法（syntax）と意味論（semantics）を定義することで定義される。文法は計算をどのように表わすかという決まりで、それ自体では意味を持たない。これをどのように解釈して人間の考えるような意味を導き出すか、というのが意味論。どちらも厳密に定義されるので、これに従えば人間でも機会でも同じように文法を解釈し、意味を導出できる。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_1_introduction">3.1 Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ここで紹介されてる文法では <code>succ true</code> みたいな一見意味のない項も可能なわけで、人間はこれを見ればオイオイ、
と思うけど文法的にはまったく問題ない。こういう誤りを防ぐのが型システムでもある。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_2_syntax">3.2 Syntax</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ここでは文法的な定義をしているだけなので、その意味というのは考えない。とりあえずここでは人間の考える（<code>true</code>/<code>false</code>/<code>if</code>
だけの）計算のメンタルモデルがうまいこと形式的に表現できるように注意深く定義してやる。「意味」を考えるのはそのあと。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_4_semantic_styles">3.4 Semantic Styles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>意味論（semantics）というのはこうやって作りあげた形式的な言語に、どうやって人間が想定するような「意味」を与えるか（どう評価するか）、というもの。
これも厳密に与えることができる。</p>
</div>
<div class="paragraph">
<p>意味論にもいくつかの方法がある:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Operational semantics</dt>
<dd>
<p>項に対する操作を定義することで、項の意味を導くもの。この本ではこれを使う。</p>
</dd>
<dt class="hdlist1">Denotational semantics</dt>
<dd>
<p>数学的な対象を「意味」として、項から対象への関数を考えるようなもの。Domain theory と関係があるらしい。</p>
</dd>
<dt class="hdlist1">Axiomatic semantics</dt>
<dd>
<p>不変条件（invariant）と関係があるらしい？　項の評価じゃなくルール自体をその意味とする？　なんとなくイメージできる気はするけど具体的に分からないのでスルー。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_5_evaluation">3.5 Evaluation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_def_3_5_2">Def. 3.5.2</h3>
<div class="paragraph">
<p>何か直感的に分からない。ある規則を満たす（satisfy）関係は、その規則のすべてのインスタンスにおいて、結論（conculusion）がその関係に含まれているか、または前提（premise）のいずれかが関係に含まれていない。この後半がよくわからなくて、前提が関係に含まれているとどう不味いんだろう……。少なくとも今考えている言語はシンプルすぎていい具体例が挙げられなそう。</p>
</div>
<hr>
<div class="paragraph">
<p>導出（derivation）というのは一つの evaluation statement \(t \longrightarrow t'\) を言語のルール（<strong>E-IFTRUE</strong> とか）から（直感的には、「縦に」）導くもの。矢印を横につなげていく操作ではない。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thm_3_5_7">Thm 3.5.7</h3>
<div class="paragraph">
<p>今のシンプルな言語では、全ての normal form は value であるけれど、今後そうとは限らない（run-time error となるものもある）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ex_3_5_13">Ex. 3-5-13</h3>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>構造的帰納法により示す。</p>
</div>
<div class="mathblock">
<div class="content">
\[t = \mathrm{if} \; t_1 \; \mathrm{then} \; t_2 \; \mathrm{else} \; t_3\]
</div>
</div>
<div class="paragraph">
<p>の場合だけ考えればよい。それ以外の場合は元の証明と同様。</p>
</div>
<div class="mathblock">
<div class="content">
\[t_1 \longrightarrow t_1', \; t_2 \longrightarrow t_2'\]
</div>
</div>
<div class="paragraph">
<p>に対し、 <strong>E-If</strong> と <strong>E-Funny2</strong> により</p>
</div>
<div class="mathblock">
<div class="content">
\[t \longrightarrow \mathrm{if} \; t_1' \; \mathrm{then} \; t_2 \; \mathrm{else} \; t_3 = t_A \\
t \longrightarrow \mathrm{if} \; t_1 \; \mathrm{then} \; t_2' \; \mathrm{else} \; t_3 = t_B\]
</div>
</div>
<div class="paragraph">
<p>であり、\(t\) から導出されるのはこの \(t_A, t_B\) しか存在しない。これらに関して</p>
</div>
<div class="mathblock">
<div class="content">
\[t_A \longrightarrow^* u_A \\
t_B \longrightarrow^* u_B\]
</div>
</div>
<div class="paragraph">
<p>（\(u_A, u_B\) は値）</p>
</div>
<div class="paragraph">
<p>であるとき、\(u_A = u_B\) であることを示す。</p>
</div>
<div class="paragraph">
<p>先の導出について、<strong>E-IF</strong> と <strong>E-FUNNY2</strong> をそれぞれもう一方に適用すると</p>
</div>
<div class="mathblock">
<div class="content">
\[t_A \longrightarrow \mathrm{if} \; t_1' \; \mathrm{then} \; t_2' \; \mathrm{else} \; t_3 \\
t_B \longrightarrow \mathrm{if} \; t_1' \; \mathrm{then} \; t_2' \; \mathrm{else} \; t_3\]
</div>
</div>
<div class="paragraph">
<p>であるので、帰納法の仮定より \(u_A = u_B\)。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ex_3_5_14">Ex. 3.5.14</h3>
<div class="paragraph">
<p><code>succ(false)</code> はこれいじょう導出できない（normal form である）が値ではなくエラー。こういう項を <code>stuck</code> と呼ぶ。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ex_3_5_16">Ex. 3.5.16</h3>
<div class="paragraph">
<p><code>badnat</code>, <code>badbool</code>, <code>wrong</code> による <code>stuck</code> の表現。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>とにかく何でも評価することができて、最後には値か、そうでなければ（= <code>stuck</code> となる場合）<code>wrong</code> に評価される、という風になっていればよいと思う。なので、</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>すべての値または <code>wrong</code> を除く項が評価可能であればよい。</p>
</li>
<li>
<p>構造的帰納で証明できそうということで省略。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ex_3_5_17">Ex. 3.5.17</h3>
<div class="paragraph">
<p>Operational semantics のもう一つの一般的なスタイル、<em>big-step</em> (<em>natural semantics</em>) について。項が最終的にどんな値に評価されるか、という観点の関係 \(\Downarrow\) を用意し、それに基いた導出をおこなうスタイル。ちなみにこれまでやってきたのは <em>small-step</em> である。ここでこの 2 つのスタイルが一致すること、つまり \(t \longrightarrow^* v \iff t \Downarrow v\) を示す。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>構造的帰納法により示す。</p>
</div>
<div class="mathblock">
<div class="content">
\[t = \mathrm{if} \; t_1 \; \mathrm{then} \; t_2 \; \mathrm{else} \; t_3\]
</div>
</div>
<div class="paragraph">
<p>の場合だけを考える。</p>
</div>
<div class="paragraph">
<p>\(\Longleftarrow\) について。</p>
</div>
<div class="paragraph">
<p>\(t \Downarrow v\) とする。これを導出できたのは <strong>B-IfTrue</strong> か <strong>B-IfFalse</strong> のどちらかである。</p>
</div>
<div class="paragraph">
<p><strong>B-IfTrue</strong> の場合を考えると、\(t_1 \Downarrow \mathrm{true}\), \(t_2 \Downarrow v\) である。すると帰納法の仮定より</p>
</div>
<div class="mathblock">
<div class="content">
\[t_1 \longrightarrow^* \mathrm{true} \\
t_2 \longrightarrow^* v\]
</div>
</div>
<div class="paragraph">
<p>\(t_1 \longrightarrow^* \mathrm{true}\) のとき \(\mathrm{if} \; t_1 \; \mathrm{then} \; t_2 \; \mathrm{else} \; t_3 \longrightarrow^* t_2\) であることはすぐに示せる。結局</p>
</div>
<div class="mathblock">
<div class="content">
\[t \longrightarrow^* t_2 \longrightarrow^* v\]
</div>
</div>
<div class="paragraph">
<p><strong>B-IfFalse</strong> の場合も同様。</p>
</div>
<div class="paragraph">
<p>\(\Longrightarrow\) について。</p>
</div>
<div class="paragraph">
<p>\(t \longrightarrow^* v\) とする。</p>
</div>
<div class="paragraph">
<p>\(t_1 \longrightarrow^* \mathrm{true}\) とすると \(t \longrightarrow^* t_2\)。ここで</p>
</div>
<div class="mathblock">
<div class="content">
\[t \longrightarrow^* t_2 \longrightarrow^* v_2\]
</div>
</div>
<div class="paragraph">
<p>とすると定理 3.5.11 より \(v_2 = v\)。よって</p>
</div>
<div class="mathblock">
<div class="content">
\[t_1 \Downarrow \mathrm{true} \\
t_2 \Downarrow v\]
</div>
</div>
<div class="paragraph">
<p><strong>B-IfTrue</strong> より \(t \Downarrow v\)。\(t_1 \longrightarrow^* \mathrm{false}\) の場合も同様。それ以外の場合 \(t\) は stuck する。</p>
</div>
</div>
</div>
</div>
</div>
</div><nav class="pager"><a rel="prev" href="../01_Introduction/">≪ 1. Introduction</a><a rel="next" href="../05_The-Untyped-Lambda-Calculus/">5. The Untyped Lambda-Calclus ≫</a></nav></article><aside><div class="textbook"><h1 class="title">Types and Programming Languages</h1><ul class="links"><li><a href="http://www.amazon.co.jp/gp/product/B00AJXZ5JE/ref=as_li_ss_il?ie=UTF8camp=247&amp;creative=7399&amp;creativeASIN=B00AJXZ5JE&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/51mYUDN2%2BIL.jpg" ><br>Types and Programming Languages</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=B00AJXZ5JE" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li><li><a href="http://www.amazon.co.jp/gp/product/4274069117/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=4274069117&amp;linkCode=as2&amp;tag=tokyoenvious-22"><img border="0" src="http://ecx.images-amazon.com/images/I/41gusdgRAkL.jpg" ><br>型システム入門</a><img src="http://ir-jp.amazon-adsystem.com/e/ir?t=tokyoenvious-22&amp;l=as2&amp;o=9&amp;a=4274069117" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
</li></ul></div><ul class="sitemap"><li><strong><a href="../">Types and Programming Languages</a></strong><ul><li><a href="../01_Introduction/">1. Introduction</a></li><li><a href="./">3. Untyped Arithmetic Expressions</a></li><li><a href="../05_The-Untyped-Lambda-Calculus/">5. The Untyped Lambda-Calclus</a></li></ul></li></ul></aside></div><script type="text/javascript">(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-34276254-4', 'auto');
ga('send', 'pageview');</script></body></html>